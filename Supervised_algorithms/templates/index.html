<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Supervised Learning Visualizer</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 30px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .sidebar {
            background: #f8f9fa;
            padding: 30px;
            border-right: 1px solid #e9ecef;
        }

        .sidebar h2 {
            color: #495057;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
        }

        .form-group select,
        .form-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .form-group select:focus,
        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            width: 100%;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .content-area {
            padding: 30px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border-left: 4px solid #667eea;
        }

        .metric-card h3 {
            color: #495057;
            font-size: 0.9rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .metric-card .value {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
        }

        .progress-container {
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .status-text {
            text-align: center;
            color: #495057;
            font-weight: 600;
        }

        .visualization-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .plot-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .plot-container h3 {
            margin-bottom: 15px;
            color: #495057;
            text-align: center;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .visualization-container {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ¤– Supervised Learning Visualizer</h1>
            <p>Real-time step-by-step training visualizations for machine learning algorithms</p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <h2>ðŸ“‹ Configuration</h2>
                
                <div class="form-group">
                    <label for="datasetType">Dataset Type</label>
                    <select id="datasetType">
                        <option value="synthetic_classification">Synthetic Classification</option>
                        <option value="synthetic_regression">Synthetic Regression</option>
                        <option value="real_dataset">Real Dataset</option>
                    </select>
                </div>

                <div class="form-group" id="syntheticParams">
                    <label for="nSamples">Number of Samples</label>
                    <input type="number" id="nSamples" value="500" min="100" max="1000">
                    
                    <label for="nFeatures">Number of Features</label>
                    <input type="number" id="nFeatures" value="2" min="1" max="10">
                    
                    <label for="nClasses">Number of Classes</label>
                    <input type="number" id="nClasses" value="2" min="2" max="4">
                </div>

                <div class="form-group" id="realDatasetParams" style="display: none;">
                    <label for="realDataset">Select Dataset</label>
                    <select id="realDataset">
                        <option value="iris">Iris (Classification)</option>
                        <option value="california">California Housing (Regression)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="algorithm">Algorithm</label>
                    <select id="algorithm">
                        <option value="linear_regression">Linear Regression</option>
                        <option value="logistic_regression">Logistic Regression</option>
                        <option value="decision_tree">Decision Tree</option>
                        <option value="svm">Support Vector Machine</option>
                        <option value="knn">K-Nearest Neighbors</option>
                    </select>
                </div>

                <button class="btn" id="generateDataBtn">Generate Data</button>
                <button class="btn" id="trainModelBtn" disabled>Train Model</button>
            </div>

            <div class="content-area">
                <div id="alertContainer"></div>
                
                <div class="metrics-grid" id="metricsGrid" style="display: none;">
                    <div class="metric-card">
                        <h3>Total Samples</h3>
                        <div class="value" id="totalSamples">-</div>
                    </div>
                    <div class="metric-card">
                        <h3>Features</h3>
                        <div class="value" id="features">-</div>
                    </div>
                    <div class="metric-card">
                        <h3>Training Samples</h3>
                        <div class="value" id="trainingSamples">-</div>
                    </div>
                    <div class="metric-card">
                        <h3>Test Samples</h3>
                        <div class="value" id="testSamples">-</div>
                    </div>
                </div>

                <div class="progress-container" id="progressContainer">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="status-text" id="statusText">Ready to train...</div>
                </div>

                <div class="visualization-container" id="visualizationContainer" style="display: none;">
                    <div class="plot-container">
                        <h3>Training Progress</h3>
                        <div id="trainingPlot"></div>
                    </div>
                    <div class="plot-container">
                        <h3>Model Performance</h3>
                        <div id="performancePlot"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentData = null;
        let trainingSteps = [];

        // DOM elements
        const datasetType = document.getElementById('datasetType');
        const syntheticParams = document.getElementById('syntheticParams');
        const realDatasetParams = document.getElementById('realDatasetParams');
        const generateDataBtn = document.getElementById('generateDataBtn');
        const trainModelBtn = document.getElementById('trainModelBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const statusText = document.getElementById('statusText');
        const visualizationContainer = document.getElementById('visualizationContainer');

        // Event listeners
        datasetType.addEventListener('change', toggleDatasetParams);
        generateDataBtn.addEventListener('click', generateData);
        trainModelBtn.addEventListener('click', trainModel);

        function toggleDatasetParams() {
            if (datasetType.value === 'real_dataset') {
                syntheticParams.style.display = 'none';
                realDatasetParams.style.display = 'block';
            } else {
                syntheticParams.style.display = 'block';
                realDatasetParams.style.display = 'none';
            }
        }

        function showAlert(message, type = 'success') {
            const alertContainer = document.getElementById('alertContainer');
            alertContainer.innerHTML = `<div class="alert alert-${type}">${message}</div>`;
            alertContainer.style.display = 'block';
            
            setTimeout(() => {
                alertContainer.style.display = 'none';
            }, 5000);
        }

        async function generateData() {
            try {
                generateDataBtn.disabled = true;
                generateDataBtn.textContent = 'Generating...';

                const data = {
                    dataset_type: datasetType.value
                };

                if (datasetType.value === 'synthetic_classification' || datasetType.value === 'synthetic_regression') {
                    data.n_samples = parseInt(document.getElementById('nSamples').value);
                    data.n_features = parseInt(document.getElementById('nFeatures').value);
                    if (datasetType.value === 'synthetic_classification') {
                        data.n_classes = parseInt(document.getElementById('nClasses').value);
                    }
                } else if (datasetType.value === 'real_dataset') {
                    data.dataset_name = document.getElementById('realDataset').value;
                }

                const response = await fetch('/api/generate_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });

                const result = await response.json();

                if (result.success) {
                    currentData = result.data;
                    updateMetrics(result.dataset_info);
                    trainModelBtn.disabled = false;
                    showAlert('Data generated successfully!');
                } else {
                    showAlert('Failed to generate data', 'error');
                }
            } catch (error) {
                showAlert('Error generating data: ' + error.message, 'error');
            } finally {
                generateDataBtn.disabled = false;
                generateDataBtn.textContent = 'Generate Data';
            }
        }

        function updateMetrics(datasetInfo) {
            document.getElementById('totalSamples').textContent = datasetInfo.total_samples;
            document.getElementById('features').textContent = datasetInfo.features;
            document.getElementById('trainingSamples').textContent = datasetInfo.training_samples;
            document.getElementById('testSamples').textContent = datasetInfo.test_samples;
            document.getElementById('metricsGrid').style.display = 'grid';
        }

        async function trainModel() {
            try {
                trainModelBtn.disabled = true;
                trainModelBtn.textContent = 'Training...';
                progressContainer.style.display = 'block';
                visualizationContainer.style.display = 'grid';

                const algorithm = document.getElementById('algorithm').value;
                const datasetType = document.getElementById('datasetType').value;
                
                // Add parameters for different algorithms
                let requestData = { 
                    algorithm, 
                    dataset_type: datasetType 
                };
                
                if (algorithm === 'decision_tree') {
                    requestData.max_depth = 5; // Default value, could be made configurable
                } else if (algorithm === 'knn') {
                    requestData.n_neighbors = 5; // Default value, could be made configurable
                }

                const response = await fetch('/api/train_model', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                const result = await response.json();

                if (result.success) {
                    trainingSteps = result.training_steps;
                    animateTraining();
                } else {
                    showAlert('Failed to train model: ' + result.error, 'error');
                }
            } catch (error) {
                showAlert('Error training model: ' + error.message, 'error');
            } finally {
                trainModelBtn.disabled = false;
                trainModelBtn.textContent = 'Train Model';
            }
        }

        function animateTraining() {
            let currentStep = 0;
            
            function updateStep() {
                if (currentStep >= trainingSteps.length) {
                    statusText.textContent = 'Training completed!';
                    return;
                }

                const step = trainingSteps[currentStep];
                
                // Update progress
                progressFill.style.width = (step.progress * 100) + '%';
                statusText.textContent = `Training... ${(step.progress * 100).toFixed(1)}% complete`;

                // Update visualizations
                updateTrainingPlot(currentStep);
                updatePerformancePlot(currentStep);

                currentStep++;
                setTimeout(updateStep, 200);
            }

            updateStep();
        }

        function updateTrainingPlot(stepIndex) {
            const step = trainingSteps[stepIndex];
            const algorithm = document.getElementById('algorithm').value;

            if (algorithm === 'linear_regression') {
                // Create regression line plot
                const xRange = currentData.X_test.map(row => row[0]);
                const yActual = currentData.y_test;
                const yPred = step.predictions;

                const trace1 = {
                    x: xRange,
                    y: yActual,
                    mode: 'markers',
                    name: 'Actual',
                    marker: { color: 'blue', size: 8 }
                };

                const trace2 = {
                    x: xRange,
                    y: yPred,
                    mode: 'markers',
                    name: 'Predictions',
                    marker: { color: 'red', size: 8 }
                };

                const layout = {
                    title: 'Linear Regression Training',
                    xaxis: { title: 'Feature 1' },
                    yaxis: { title: 'Target' },
                    height: 400
                };

                Plotly.newPlot('trainingPlot', [trace1, trace2], layout);
            } else if (algorithm === 'logistic_regression') {
                // Create decision boundary plot
                const x1 = currentData.X_test.map(row => row[0]);
                const x2 = currentData.X_test.map(row => row[1]);
                const y = currentData.y_test;
                const predictions = step.predictions;

                const trace1 = {
                    x: x1.filter((_, i) => y[i] === 0),
                    y: x2.filter((_, i) => y[i] === 0),
                    mode: 'markers',
                    name: 'Class 0',
                    marker: { color: 'blue', size: 8 }
                };

                const trace2 = {
                    x: x1.filter((_, i) => y[i] === 1),
                    y: x2.filter((_, i) => y[i] === 1),
                    mode: 'markers',
                    name: 'Class 1',
                    marker: { color: 'red', size: 8 }
                };

                const layout = {
                    title: 'Logistic Regression Decision Boundary',
                    xaxis: { title: 'Feature 1' },
                    yaxis: { title: 'Feature 2' },
                    height: 400
                };

                Plotly.newPlot('trainingPlot', [trace1, trace2], layout);
            } else if (algorithm === 'decision_tree') {
                // Create decision tree visualization
                const x1 = currentData.X_test.map(row => row[0]);
                const x2 = currentData.X_test.map(row => row[1]);
                const y = currentData.y_test;
                const predictions = step.predictions;

                const trace1 = {
                    x: x1.filter((_, i) => y[i] === 0),
                    y: x2.filter((_, i) => y[i] === 0),
                    mode: 'markers',
                    name: 'Class 0 (Actual)',
                    marker: { color: 'blue', size: 8 }
                };

                const trace2 = {
                    x: x1.filter((_, i) => y[i] === 1),
                    y: x2.filter((_, i) => y[i] === 1),
                    mode: 'markers',
                    name: 'Class 1 (Actual)',
                    marker: { color: 'red', size: 8 }
                };

                const trace3 = {
                    x: x1.filter((_, i) => predictions[i] === 0),
                    y: x2.filter((_, i) => predictions[i] === 0),
                    mode: 'markers',
                    name: 'Class 0 (Predicted)',
                    marker: { color: 'lightblue', size: 6, symbol: 'diamond' }
                };

                const trace4 = {
                    x: x1.filter((_, i) => predictions[i] === 1),
                    y: x2.filter((_, i) => predictions[i] === 1),
                    mode: 'markers',
                    name: 'Class 1 (Predicted)',
                    marker: { color: 'pink', size: 6, symbol: 'diamond' }
                };

                const layout = {
                    title: 'Decision Tree Classification',
                    xaxis: { title: 'Feature 1' },
                    yaxis: { title: 'Feature 2' },
                    height: 400
                };

                Plotly.newPlot('trainingPlot', [trace1, trace2, trace3, trace4], layout);
            } else if (algorithm === 'svm') {
                // Create SVM visualization (similar to decision tree for classification)
                const x1 = currentData.X_test.map(row => row[0]);
                const x2 = currentData.X_test.map(row => row[1]);
                const y = currentData.y_test;
                const predictions = step.predictions;

                const trace1 = {
                    x: x1.filter((_, i) => y[i] === 0),
                    y: x2.filter((_, i) => y[i] === 0),
                    mode: 'markers',
                    name: 'Class 0 (Actual)',
                    marker: { color: 'blue', size: 8 }
                };

                const trace2 = {
                    x: x1.filter((_, i) => y[i] === 1),
                    y: x2.filter((_, i) => y[i] === 1),
                    mode: 'markers',
                    name: 'Class 1 (Actual)',
                    marker: { color: 'red', size: 8 }
                };

                const trace3 = {
                    x: x1.filter((_, i) => predictions[i] === 0),
                    y: x2.filter((_, i) => predictions[i] === 0),
                    mode: 'markers',
                    name: 'Class 0 (Predicted)',
                    marker: { color: 'lightblue', size: 6, symbol: 'diamond' }
                };

                const trace4 = {
                    x: x1.filter((_, i) => predictions[i] === 1),
                    y: x2.filter((_, i) => predictions[i] === 1),
                    mode: 'markers',
                    name: 'Class 1 (Predicted)',
                    marker: { color: 'pink', size: 6, symbol: 'diamond' }
                };

                const layout = {
                    title: 'SVM Classification',
                    xaxis: { title: 'Feature 1' },
                    yaxis: { title: 'Feature 2' },
                    height: 400
                };

                Plotly.newPlot('trainingPlot', [trace1, trace2, trace3, trace4], layout);
            } else if (algorithm === 'knn') {
                // Create KNN visualization (similar to decision tree for classification)
                const x1 = currentData.X_test.map(row => row[0]);
                const x2 = currentData.X_test.map(row => row[1]);
                const y = currentData.y_test;
                const predictions = step.predictions;

                const trace1 = {
                    x: x1.filter((_, i) => y[i] === 0),
                    y: x2.filter((_, i) => y[i] === 0),
                    mode: 'markers',
                    name: 'Class 0 (Actual)',
                    marker: { color: 'blue', size: 8 }
                };

                const trace2 = {
                    x: x1.filter((_, i) => y[i] === 1),
                    y: x2.filter((_, i) => y[i] === 1),
                    mode: 'markers',
                    name: 'Class 1 (Actual)',
                    marker: { color: 'red', size: 8 }
                };

                const trace3 = {
                    x: x1.filter((_, i) => predictions[i] === 0),
                    y: x2.filter((_, i) => predictions[i] === 0),
                    mode: 'markers',
                    name: 'Class 0 (Predicted)',
                    marker: { color: 'lightblue', size: 6, symbol: 'diamond' }
                };

                const trace4 = {
                    x: x1.filter((_, i) => predictions[i] === 1),
                    y: x2.filter((_, i) => predictions[i] === 1),
                    mode: 'markers',
                    name: 'Class 1 (Predicted)',
                    marker: { color: 'pink', size: 6, symbol: 'diamond' }
                };

                const layout = {
                    title: 'KNN Classification',
                    xaxis: { title: 'Feature 1' },
                    yaxis: { title: 'Feature 2' },
                    height: 400
                };

                Plotly.newPlot('trainingPlot', [trace1, trace2, trace3, trace4], layout);
            }
        }

        function updatePerformancePlot(stepIndex) {
            const steps = trainingSteps.slice(0, stepIndex + 1);
            const algorithm = document.getElementById('algorithm').value;

            if (algorithm === 'linear_regression') {
                const x = steps.map((_, i) => i);
                const mse = steps.map(step => step.mse);
                const r2 = steps.map(step => step.r2);

                const trace1 = {
                    x: x,
                    y: mse,
                    mode: 'lines+markers',
                    name: 'MSE',
                    line: { color: 'orange', width: 2 }
                };

                const trace2 = {
                    x: x,
                    y: r2,
                    mode: 'lines+markers',
                    name: 'RÂ²',
                    line: { color: 'purple', width: 2 },
                    yaxis: 'y2'
                };

                const layout = {
                    title: 'Model Performance Metrics',
                    xaxis: { title: 'Training Step' },
                    yaxis: { title: 'MSE', side: 'left' },
                    yaxis2: { title: 'RÂ²', side: 'right', overlaying: 'y' },
                    height: 400
                };

                Plotly.newPlot('performancePlot', [trace1, trace2], layout);
            } else if (algorithm === 'logistic_regression') {
                const x = steps.map((_, i) => i);
                const accuracy = steps.map(step => step.accuracy);

                const trace = {
                    x: x,
                    y: accuracy,
                    mode: 'lines+markers',
                    name: 'Accuracy',
                    line: { color: 'blue', width: 2 }
                };

                const layout = {
                    title: 'Model Accuracy',
                    xaxis: { title: 'Training Step' },
                    yaxis: { title: 'Accuracy' },
                    height: 400
                };

                Plotly.newPlot('performancePlot', [trace], layout);
            } else if (algorithm === 'decision_tree') {
                const x = steps.map((_, i) => i);
                const accuracy = steps.map(step => step.accuracy);
                const mse = steps.map(step => step.mse);
                const r2 = steps.map(step => step.r2);

                if (accuracy && accuracy.length > 0) {
                    // Classification task
                    const trace = {
                        x: x,
                        y: accuracy,
                        mode: 'lines+markers',
                        name: 'Accuracy',
                        line: { color: 'green', width: 2 }
                    };

                    const layout = {
                        title: 'Decision Tree Accuracy',
                        xaxis: { title: 'Training Step' },
                        yaxis: { title: 'Accuracy' },
                        height: 400
                    };

                    Plotly.newPlot('performancePlot', [trace], layout);
                } else if (mse && mse.length > 0) {
                    // Regression task
                    const trace1 = {
                        x: x,
                        y: mse,
                        mode: 'lines+markers',
                        name: 'MSE',
                        line: { color: 'orange', width: 2 }
                    };

                    const trace2 = {
                        x: x,
                        y: r2,
                        mode: 'lines+markers',
                        name: 'RÂ²',
                        line: { color: 'purple', width: 2 },
                        yaxis: 'y2'
                    };

                    const layout = {
                        title: 'Decision Tree Performance Metrics',
                        xaxis: { title: 'Training Step' },
                        yaxis: { title: 'MSE', side: 'left' },
                        yaxis2: { title: 'RÂ²', side: 'right', overlaying: 'y' },
                        height: 400
                    };

                    Plotly.newPlot('performancePlot', [trace1, trace2], layout);
                }
            } else if (algorithm === 'svm') {
                const x = steps.map((_, i) => i);
                const accuracy = steps.map(step => step.accuracy);
                const mse = steps.map(step => step.mse);
                const r2 = steps.map(step => step.r2);

                if (accuracy && accuracy.length > 0) {
                    // Classification task
                    const trace = {
                        x: x,
                        y: accuracy,
                        mode: 'lines+markers',
                        name: 'Accuracy',
                        line: { color: 'green', width: 2 }
                    };

                    const layout = {
                        title: 'SVM Accuracy',
                        xaxis: { title: 'Training Step' },
                        yaxis: { title: 'Accuracy' },
                        height: 400
                    };

                    Plotly.newPlot('performancePlot', [trace], layout);
                } else if (mse && mse.length > 0) {
                    // Regression task
                    const trace1 = {
                        x: x,
                        y: mse,
                        mode: 'lines+markers',
                        name: 'MSE',
                        line: { color: 'orange', width: 2 }
                    };

                    const trace2 = {
                        x: x,
                        y: r2,
                        mode: 'lines+markers',
                        name: 'RÂ²',
                        line: { color: 'purple', width: 2 },
                        yaxis: 'y2'
                    };

                    const layout = {
                        title: 'SVM Performance Metrics',
                        xaxis: { title: 'Training Step' },
                        yaxis: { title: 'MSE', side: 'left' },
                        yaxis2: { title: 'RÂ²', side: 'right', overlaying: 'y' },
                        height: 400
                    };

                    Plotly.newPlot('performancePlot', [trace1, trace2], layout);
                }
            } else if (algorithm === 'knn') {
                const x = steps.map((_, i) => i);
                const accuracy = steps.map(step => step.accuracy);
                const mse = steps.map(step => step.mse);
                const r2 = steps.map(step => step.r2);

                if (accuracy && accuracy.length > 0) {
                    // Classification task
                    const trace = {
                        x: x,
                        y: accuracy,
                        mode: 'lines+markers',
                        name: 'Accuracy',
                        line: { color: 'green', width: 2 }
                    };

                    const layout = {
                        title: 'KNN Accuracy',
                        xaxis: { title: 'Training Step' },
                        yaxis: { title: 'Accuracy' },
                        height: 400
                    };

                    Plotly.newPlot('performancePlot', [trace], layout);
                } else if (mse && mse.length > 0) {
                    // Regression task
                    const trace1 = {
                        x: x,
                        y: mse,
                        mode: 'lines+markers',
                        name: 'MSE',
                        line: { color: 'orange', width: 2 }
                    };

                    const trace2 = {
                        x: x,
                        y: r2,
                        mode: 'lines+markers',
                        name: 'RÂ²',
                        line: { color: 'purple', width: 2 },
                        yaxis: 'y2'
                    };

                    const layout = {
                        title: 'KNN Performance Metrics',
                        xaxis: { title: 'Training Step' },
                        yaxis: { title: 'MSE', side: 'left' },
                        yaxis2: { title: 'RÂ²', side: 'right', overlaying: 'y' },
                        height: 400
                    };

                    Plotly.newPlot('performancePlot', [trace1, trace2], layout);
                }
            }
        }

        // Initialize
        toggleDatasetParams();
    </script>
</body>
</html>
